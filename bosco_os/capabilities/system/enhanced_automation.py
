"""
Bosco Core - Enhanced Automation Module
Handles complex PC automation commands
"""

import subprocess
import time
import os
import re

try:
    import pyautogui
    pyautogui.FAILSAFE = True
    PYAUTOGUI_AVAILABLE = True
except:
    pyautogui = None
    PYAUTOGUI_AVAILABLE = False

try:
    import pyperclip
    PYPERCLIP_AVAILABLE = True
except:
    pyperclip = None
    PYPERCLIP_AVAILABLE = False


class EnhancedAutomation:
    """Advanced PC automation with natural language commands"""
    
    def __init__(self):
        self.command_history = []
        self.app_commands = {
            'notepad': 'notepad',
            'text editor': 'notepad',
            'terminal': 'gnome-terminal',
            'cmd': 'cmd',
            'vscode': 'code',
            'visual studio': 'code',
            'chrome': 'google-chrome',
            'browser': 'google-chrome',
            'firefox': 'firefox',
        }
    
    def parse_command(self, command):
        command = command.lower().strip()
        self.command_history.append(command)
        actions = []
        
        # Pattern: "open [app] and write [text]"
        open_write_pattern = r'open\s+(?:the\s+)?(\w+)\s+and\s+(?:write|type)\s+(.+)'
        match = re.search(open_write_pattern, command)
        if match:
            app = match.group(1)
            text = match.group(2).strip()
            actions.append(('open_app', app))
            actions.append(('wait', 1.5))
            actions.append(('type_text', text))
            return actions
        
        # Pattern: "open [app]"
        open_pattern = r'open\s+(?:the\s+)?(\w+(?:\s+\w+)?)'
        match = re.search(open_pattern, command)
        if match and 'write' not in command and 'type' not in command:
            actions.append(('open_app', match.group(1)))
            return actions
        
        # Pattern: "write [text]" or "type [text]"
        if command.startswith('write ') or command.startswith('type '):
            text = command.replace('write ', '').replace('type ', '').strip()
            actions.append(('type_text', text))
            return actions
        
        # Pattern: "run [command]"
        if command.startswith('run '):
            actions.append(('run_terminal', command.replace('run ', '').strip()))
            return actions
        
        # Single actions
        if 'screenshot' in command:
            actions.append(('screenshot',))
        elif 'minimize' in command:
            actions.append(('minimize',))
        elif 'maximize' in command:
            actions.append(('maximize',))
        
        return actions
    
    def execute_actions(self, actions):
        results = []
        for action in actions:
            if action[0] == 'open_app':
                result = self.open_app(action[1])
            elif action[0] == 'wait':
                time.sleep(action[1])
                result = f"Waited {action[1]}s"
            elif action[0] == 'type_text':
                result = self.type_text(action[1])
            elif action[0] == 'run_terminal':
                result = self.run_terminal(action[1])
            elif action[0] == 'screenshot':
                result = self.screenshot()
            else:
                result = f"Unknown action: {action[0]}"
            results.append(result)
            time.sleep(0.3)
        return results
    
    def process_command(self, command):
        actions = self.parse_command(command)
        if not actions:
            return [f"Could not understand: {command}"]
        return self.execute_actions(actions)
    
    def open_app(self, app_name):
        app = app_name.lower().strip()
        cmd = self.app_commands.get(app, app)
        try:
            if os.name == 'nt':
                subprocess.Popen(cmd, shell=True)
            else:
                subprocess.Popen([cmd], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return f"Opened {app_name}"
        except Exception as e:
            return f"Error: {e}"
    
    def type_text(self, text):
        try:
            if PYPERCLIP_AVAILABLE:
                pyperclip.copy(text)
                if PYAUTOGUI_AVAILABLE:
                    pyautogui.hotkey('ctrl', 'v')
                return f"Typed: {text}"
            elif PYAUTOGUI_AVAILABLE:
                pyautogui.write(text)
                return f"Typed: {text}"
            return "No typing available"
        except Exception as e:
            return f"Error: {e}"
    
    def run_terminal(self, command):
        try:
            result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=30)
            output = result.stdout[:500] if result.stdout else result.stderr[:500]
            return output if output else "Done"
        except Exception as e:
            return f"Error: {e}"
    
    def screenshot(self):
        try:
            if PYAUTOGUI_AVAILABLE:
                path = f"{os.path.expanduser('~')}/Pictures/bosco_screenshot_{int(time.time())}.png"
                pyautogui.screenshot(path)
                return f"Saved: {path}"
            return "Not available"
        except Exception as e:
            return f"Error: {e}"


automation = EnhancedAutomation()


def process_command(cmd):
    return automation.process_command(cmd)


if __name__ == "__main__":
    print("Enhanced Automation Ready")
    test = ["open notepad", "type hello world", "run ls"]
    for cmd in test:
        print(f"> {cmd}")
        print(f"  {process_command(cmd)}")

